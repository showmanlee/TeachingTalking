기본적인 테스트 순서:
1. 카드들을 순서대로 받는다.
2. 해당 카드들의 조합형을 불러온다.
2-1. 만약 이름도 없는 카드가 등장한 경우 오류를 뱉는다(해당 카드는 학습이 필요합니다!).
3. 조합형들로 완성된 문장을 표시하고, 해당 문장이 어떤지를 묻는다(O, △, X).
3-1. 만약 해당 문장이 올바르다면, 사용된 조합형들의 가중치를 크게(+3) 올리고(또는 만들고) 끝낸다.
3-2. 만약 해당 문장이 올바르지만 어색하다면, 가중치를 적게(+1) 올린 뒤, 다르게 문장을 조합한다.
3-3. 만약 해당 문장이 틀렸다면, 가중치를 올리지 않고 다르게 문장을 조합한다.
4. 문장을 다르게 조합해야 하는 경우, 차순위 조합형으로 새롭게 문장을 조합해 3의 과정을 반복한다.

조합식 우선 순위
0. 이름 없음 - 에러
1. 앞/뒤와 카드군이 맞는 조합형
2. 앞/뒤와 카드군이 다른 조합형
3. 윈래 이름
1/2의 내부 순서는 가중치로 결정.

'1-1' '3-2' '2-1'일 때 기본적으로 사용되는 조합식은
1->3 1<-3/3->2 3<-2
여기서 처음과 마지막은 사용되는 조합형이 하나뿐이지만
중간에 있는 건 왼쪽과 오른쪽 등 두 가지다.
때문에 문장에 투입하기 위해서는 양쪽의 조합식을 합쳐야 한다.
일단은 두 조합식에서 겹치는 부분을 찾아내고 안 겹치는 부분을 앞뒤로 붙이는데,
왼쪽 방향의 것을 앞으로, 오른쪽 방향의 것을 뒤로 붙이는 걸로 생각하자.

일단 위의 구현이 완료되면 그 다음으로 카드군의 다른 조합형을 따와서 자동으로 조합형을 만드는 것도 고려해볼만 하다.

테스트 구현을 위해 원래 조합식 우선순위(긴 순서대로)를 테스트용 우선순위로 바꿔줘야 할 필요가 있다.
(어차피 조합식 가중치 변경은 테스트창을 나갈 때 수행함)
그리고 앞쪽과 뒷쪽 따로 우선순위를 줘야 함. 어쨌든 전용 자료구조는 필요함.
0 12 34 56 78 9 이런 식으로...
앞/뒷쪽용 카드 조합 + 원래 인덱스를 갖는 전용 알고리즘을 만든다.
+) 현재 사용되는 조합식 번호를 나타내는 리스트도 사용.

앞쪽용 우선순위와 뒷쪽용 우선순위를 별도로 마련, 우선순위 리스트에 원래 이름(카드군은 -2)도 마지막에 포함시킨다.
각 방향 우선순위 리스트에는 해당 방향의 조합식만 저장될 수 있도록 설정(이미 구문/문장 학습 과정에서 앞/뒤를 모두 저장함)
그리고 문장 종료 여부도 판단, 문장 종료 상황일 경우 문장 종료 조합식을 앞으로, 아닐 경우에는 원래 이름 뒤로 둔다.
(푸른 사과다(?) 먹다 / 푸른 사과를 먹는(?))
1. 문장 위치에 맞고 조합되는 카드군이 맞는 조합형
2. 문장 위치에 맞고 조합되는 카드군이 다른 조합형 
3. 원래 이름

앞/뒤 조합식들의 합성
만약 선택된 조합식 중 원래 이름(-2)이 하나 있다면 원래 이름을 배제하고, 남은 조합형 하나를 출력한다.
둘 다 원래 이름(-2)이면 원래 이름으로 출력한다.
--
만약 앞과 뒤가 모두 같다면 같은 것으로 출력.
다르다면 앞과 뒤에서 동일 부분을 딴 후, 그 앞뒤로 다른 부분들을 붙인다.
그런데 어차피 제시되는 조합형들은 가공 없이 모두 그 자체로 조합될 수 있는 요소들이다.
결론은 가중치 싸움? 하지만 이걸 가중치로 몰아가서는 안 된다.
eat/eats는 "앞"의 단어 단수/복수에 영향을 받고
너를/너가는 "뒤"의 단어에 영향을 받는다.
하지만 이것은 우선순위 변경 과정에서 잡을 수 있는 문제이므로
*일단은 가중치 중심으로 한다.*

우선순위는 잘못된 카드를 선택해 조정한다.
1. 어색해요/틀려요 버튼 클릭									V
2. 버튼들 숨겨지고 '어색한 카드를 선택하세요' 텍스트 표시		V
3. 이 상태에서 카드를 선택하면 우선순위 변경					
4. 우선순위가 변경되면 문장 생성
